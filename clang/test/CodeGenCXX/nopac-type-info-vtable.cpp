// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -DENABLE_TID=0 -I%S -std=c++11 -triple=aarch64-linux-gnu \
// RUN:   -fptrauth-calls -fptrauth-intrinsics \
// RUN:   -fptrauth-vtable-pointer-type-discrimination \
// RUN:   -fptrauth-vtable-pointer-address-discrimination \
// RUN:   %s -emit-llvm -o - | FileCheck %s --check-prefixes=CHECK,NODISC

// RUN: %clang_cc1 -DENABLE_TID=1 -I%S -std=c++11 -triple=aarch64-linux-gnu \
// RUN:   -fptrauth-calls -fptrauth-intrinsics \
// RUN:   -fptrauth-vtable-pointer-type-discrimination \
// RUN:   -fptrauth-vtable-pointer-address-discrimination \
// RUN:   -fptrauth-type-info-vtable-pointer-discrimination \
// RUN:   %s -emit-llvm -o - | FileCheck %s --check-prefixes=CHECK,DISC

// copied from typeinfo_nopac
namespace std {

#if __has_cpp_attribute(clang::ptrauth_vtable_pointer)
#  if __has_feature(ptrauth_type_info_vtable_pointer_discrimination)
#    define _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH \
       [[clang::ptrauth_vtable_pointer(process_independent, address_discrimination, type_discrimination)]]
#  else
#    define _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH \
       [[clang::ptrauth_vtable_pointer(process_independent, no_address_discrimination, no_extra_discrimination)]]
#  endif
#else
#  define _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH
#endif

  class __attribute__((nopac)) _LIBCPP_TYPE_INFO_VTABLE_POINTER_AUTH type_info
  {
    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
      explicit type_info(const char* __n);

  public:
      virtual ~type_info();

      virtual void test_method();
  };
} // namespace std

struct __attribute__((nopac)) TestStruct {
  virtual ~TestStruct();
  int a;
};

// CHECK-LABEL: define dso_local void @_ZN10TestStructD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(12) [[THIS:%.*]]) unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN10TestStructD2Ev(ptr noundef nonnull align 8 dereferenceable(12) [[THIS1]]) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    ret void
//
TestStruct::~TestStruct(){}

// CHECK-LABEL: define dso_local void @test_vtable(
// CHECK-SAME: ptr noundef [[T:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[T_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[T]], ptr [[T_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[T_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP0]])
// CHECK-NEXT:    ret void
//
extern "C" void test_vtable(std::type_info* t) {
  t->test_method();
}


// CHECK-LABEL: define dso_local ptr @ensure_typeinfo(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    call void @_ZN10TestStructC1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[CALL]]) #[[ATTR3]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
extern "C" const void *ensure_typeinfo() {
  return new TestStruct;
}
//// NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
// DISC: {{.*}}
// NODISC: {{.*}}

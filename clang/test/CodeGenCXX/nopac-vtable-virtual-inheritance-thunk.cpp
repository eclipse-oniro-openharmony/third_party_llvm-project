// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 %s -x c++ -std=c++11 -triple aarch64-linux-gnu -disable-llvm-passes -fptrauth-intrinsics -fptrauth-calls \
// RUN:   -fptrauth-vtable-pointer-type-discrimination -emit-llvm -O0 -o - | FileCheck --check-prefixes=CHECK,ELF %s

extern "C" int printf(const char *format, ...);

class __attribute__((nopac)) A {
public:
  A() {}
  virtual int f();
  virtual int g();
  virtual int h(...);
  virtual ~A() {}

public:
  bool necessary_field;
};

// CHECK-LABEL: define dso_local void @_ZN1CD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1CD2Ev(ptr noundef nonnull align 8 dereferenceable(8) [[THIS1]], ptr noundef @_ZTT1C)
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 8
// CHECK-NEXT:    call void @_ZN1BD2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[TMP0]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define dso_local void @_ZN1DD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1DD2Ev(ptr noundef nonnull align 8 dereferenceable(8) [[THIS1]], ptr noundef @_ZTT1D)
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 8
// CHECK-NEXT:    call void @_ZN1BD2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[TMP0]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define dso_local void @_ZN1FD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(16) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1FD2Ev(ptr noundef nonnull align 8 dereferenceable(16) [[THIS1]], ptr noundef @_ZTT1F)
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 32
// CHECK-NEXT:    call void @_ZN1ED2Ev(ptr noundef nonnull align 8 dereferenceable(8) [[TMP0]])
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 16
// CHECK-NEXT:    call void @_ZN1BD2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[TMP1]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define dso_local void @_ZN1GD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(16) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1GD2Ev(ptr noundef nonnull align 8 dereferenceable(16) [[THIS1]], ptr noundef @_ZTT1G)
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 24
// CHECK-NEXT:    call void @_ZN1BD2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[TMP0]])
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 16
// CHECK-NEXT:    call void @_ZN1ED2Ev(ptr noundef nonnull align 8 dereferenceable(8) [[TMP1]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1E1fEv(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 1
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1A1fEv(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(9) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 0
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1E1gEv(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 1
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1A1gEv(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(9) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 0
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1D1gEv(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 0
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1E1hEz(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]], ...) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 1
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1A1hEz(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(9) [[THIS:%.*]], ...) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 0
//

// CHECK-LABEL: define dso_local noundef i32 @_ZN1D1hEz(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]], ...) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32 0
//

class __attribute__((nopac)) B : public A {
public:


  B() : A() {}
  virtual ~B() {}
};

class __attribute__((nopac)) C : public virtual B {
public:
  C() : B() {}
  ~C();
};

class __attribute__((nopac)) D : public virtual B {
public:
  D() : B() {}
  ~D();
  virtual int g();
  virtual int h(...);
};

class __attribute__((nopac)) E {
public:
  virtual int f();
  virtual int g();
  virtual int h(...);
  virtual ~E(){};
};

class __attribute__((nopac)) F : public C, public D, public virtual E {
  ~F();
};

class __attribute__((nopac)) G : public virtual E, public C, public D {
  ~G();
};

C::~C() {}
D::~D() {}
F::~F() {}
G::~G() {}
int E::f() { return 1; }
int A::f() { return 0; }
int E::g() { return 1; }
int A::g() { return 0; }
int D::g() { return 0; }

int E::h(...) { return 1; }
int A::h(...) { return 0; }
int D::h(...) { return 0; }

// CHECK-LABEL: define dso_local noundef i32 @main(
// CHECK-SAME: ) #[[ATTR3:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[ANS:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[B:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[E:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 24) #[[ATTR8:[0-9]+]]
// CHECK-NEXT:    call void @_ZN1CC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[CALL]])
// CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[CALL]], null
// CHECK-NEXT:    br i1 [[TMP0]], label %[[CAST_END:.*]], label %[[CAST_NOTNULL:.*]]
// CHECK:       [[CAST_NOTNULL]]:
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[CALL]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR:%.*]] = getelementptr i8, ptr [[VTABLE]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[CALL]], i64 [[VBASE_OFFSET]]
// CHECK-NEXT:    br label %[[CAST_END]]
// CHECK:       [[CAST_END]]:
// CHECK-NEXT:    [[CAST_RESULT:%.*]] = phi ptr [ [[ADD_PTR]], %[[CAST_NOTNULL]] ], [ null, %[[ENTRY]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT]], ptr [[ANS]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ANS]], align 8
// CHECK-NEXT:    [[ISNULL:%.*]] = icmp eq ptr [[TMP1]], null
// CHECK-NEXT:    br i1 [[ISNULL]], label %[[DELETE_END:.*]], label %[[DELETE_NOTNULL:.*]]
// CHECK:       [[DELETE_NOTNULL]]:
// CHECK-NEXT:    [[VTABLE1:%.*]] = load ptr, ptr [[TMP1]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE1]], i64 4
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP2]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP1]])
// CHECK-NEXT:    br label %[[DELETE_END]]
// CHECK:       [[DELETE_END]]:
// CHECK-NEXT:    [[CALL2:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 24) #[[ATTR8]]
// CHECK-NEXT:    call void @_ZN1DC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[CALL2]])
// CHECK-NEXT:    [[TMP3:%.*]] = icmp eq ptr [[CALL2]], null
// CHECK-NEXT:    br i1 [[TMP3]], label %[[CAST_END8:.*]], label %[[CAST_NOTNULL3:.*]]
// CHECK:       [[CAST_NOTNULL3]]:
// CHECK-NEXT:    [[VTABLE4:%.*]] = load ptr, ptr [[CALL2]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR5:%.*]] = getelementptr i8, ptr [[VTABLE4]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET6:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR5]], align 8
// CHECK-NEXT:    [[ADD_PTR7:%.*]] = getelementptr inbounds i8, ptr [[CALL2]], i64 [[VBASE_OFFSET6]]
// CHECK-NEXT:    br label %[[CAST_END8]]
// CHECK:       [[CAST_END8]]:
// CHECK-NEXT:    [[CAST_RESULT9:%.*]] = phi ptr [ [[ADD_PTR7]], %[[CAST_NOTNULL3]] ], [ null, %[[DELETE_END]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT9]], ptr [[B]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE10:%.*]] = load ptr, ptr [[TMP4]], align 8
// CHECK-NEXT:    [[VFN11:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE10]], i64 0
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[VFN11]], align 8
// CHECK-NEXT:    [[CALL12:%.*]] = call noundef i32 [[TMP5]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP4]])
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE13:%.*]] = load ptr, ptr [[TMP6]], align 8
// CHECK-NEXT:    [[VFN14:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE13]], i64 1
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[VFN14]], align 8
// CHECK-NEXT:    [[CALL15:%.*]] = call noundef i32 [[TMP7]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP6]])
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE16:%.*]] = load ptr, ptr [[TMP8]], align 8
// CHECK-NEXT:    [[VFN17:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE16]], i64 2
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[VFN17]], align 8
// CHECK-NEXT:    [[CALL18:%.*]] = call noundef i32 (ptr, ...) [[TMP9]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP8]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[CALL19:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 24) #[[ATTR8]]
// CHECK-NEXT:    call void @_ZN1CC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[CALL19]])
// CHECK-NEXT:    [[TMP10:%.*]] = icmp eq ptr [[CALL19]], null
// CHECK-NEXT:    br i1 [[TMP10]], label %[[CAST_END25:.*]], label %[[CAST_NOTNULL20:.*]]
// CHECK:       [[CAST_NOTNULL20]]:
// CHECK-NEXT:    [[VTABLE21:%.*]] = load ptr, ptr [[CALL19]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR22:%.*]] = getelementptr i8, ptr [[VTABLE21]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET23:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR22]], align 8
// CHECK-NEXT:    [[ADD_PTR24:%.*]] = getelementptr inbounds i8, ptr [[CALL19]], i64 [[VBASE_OFFSET23]]
// CHECK-NEXT:    br label %[[CAST_END25]]
// CHECK:       [[CAST_END25]]:
// CHECK-NEXT:    [[CAST_RESULT26:%.*]] = phi ptr [ [[ADD_PTR24]], %[[CAST_NOTNULL20]] ], [ null, %[[CAST_END8]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT26]], ptr [[B]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE27:%.*]] = load ptr, ptr [[TMP11]], align 8
// CHECK-NEXT:    [[VFN28:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE27]], i64 0
// CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[VFN28]], align 8
// CHECK-NEXT:    [[CALL29:%.*]] = call noundef i32 [[TMP12]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP11]])
// CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE30:%.*]] = load ptr, ptr [[TMP13]], align 8
// CHECK-NEXT:    [[VFN31:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE30]], i64 2
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[VFN31]], align 8
// CHECK-NEXT:    [[CALL32:%.*]] = call noundef i32 (ptr, ...) [[TMP14]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP13]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[CALL33:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 24) #[[ATTR8]]
// CHECK-NEXT:    call void @_ZN1CC1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[CALL33]])
// CHECK-NEXT:    [[TMP15:%.*]] = icmp eq ptr [[CALL33]], null
// CHECK-NEXT:    br i1 [[TMP15]], label %[[CAST_END39:.*]], label %[[CAST_NOTNULL34:.*]]
// CHECK:       [[CAST_NOTNULL34]]:
// CHECK-NEXT:    [[VTABLE35:%.*]] = load ptr, ptr [[CALL33]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR36:%.*]] = getelementptr i8, ptr [[VTABLE35]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET37:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR36]], align 8
// CHECK-NEXT:    [[ADD_PTR38:%.*]] = getelementptr inbounds i8, ptr [[CALL33]], i64 [[VBASE_OFFSET37]]
// CHECK-NEXT:    br label %[[CAST_END39]]
// CHECK:       [[CAST_END39]]:
// CHECK-NEXT:    [[CAST_RESULT40:%.*]] = phi ptr [ [[ADD_PTR38]], %[[CAST_NOTNULL34]] ], [ null, %[[CAST_END25]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT40]], ptr [[B]], align 8
// CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE41:%.*]] = load ptr, ptr [[TMP16]], align 8
// CHECK-NEXT:    [[VFN42:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE41]], i64 0
// CHECK-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[VFN42]], align 8
// CHECK-NEXT:    [[CALL43:%.*]] = call noundef i32 [[TMP17]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP16]])
// CHECK-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE44:%.*]] = load ptr, ptr [[TMP18]], align 8
// CHECK-NEXT:    [[VFN45:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE44]], i64 2
// CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[VFN45]], align 8
// CHECK-NEXT:    [[CALL46:%.*]] = call noundef i32 (ptr, ...) [[TMP19]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP18]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[CALL47:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 40) #[[ATTR8]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL47]], i8 0, i64 40, i1 false)
// CHECK-NEXT:    call void @_ZN1FC1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[CALL47]])
// CHECK-NEXT:    [[TMP20:%.*]] = icmp eq ptr [[CALL47]], null
// CHECK-NEXT:    br i1 [[TMP20]], label %[[CAST_END53:.*]], label %[[CAST_NOTNULL48:.*]]
// CHECK:       [[CAST_NOTNULL48]]:
// CHECK-NEXT:    [[VTABLE49:%.*]] = load ptr, ptr [[CALL47]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR50:%.*]] = getelementptr i8, ptr [[VTABLE49]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET51:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR50]], align 8
// CHECK-NEXT:    [[ADD_PTR52:%.*]] = getelementptr inbounds i8, ptr [[CALL47]], i64 [[VBASE_OFFSET51]]
// CHECK-NEXT:    br label %[[CAST_END53]]
// CHECK:       [[CAST_END53]]:
// CHECK-NEXT:    [[CAST_RESULT54:%.*]] = phi ptr [ [[ADD_PTR52]], %[[CAST_NOTNULL48]] ], [ null, %[[CAST_END39]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT54]], ptr [[B]], align 8
// CHECK-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE55:%.*]] = load ptr, ptr [[TMP21]], align 8
// CHECK-NEXT:    [[VFN56:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE55]], i64 0
// CHECK-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[VFN56]], align 8
// CHECK-NEXT:    [[CALL57:%.*]] = call noundef i32 [[TMP22]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP21]])
// CHECK-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE58:%.*]] = load ptr, ptr [[TMP23]], align 8
// CHECK-NEXT:    [[VFN59:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE58]], i64 1
// CHECK-NEXT:    [[TMP24:%.*]] = load ptr, ptr [[VFN59]], align 8
// CHECK-NEXT:    [[CALL60:%.*]] = call noundef i32 [[TMP24]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP23]])
// CHECK-NEXT:    [[TMP25:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[VTABLE61:%.*]] = load ptr, ptr [[TMP25]], align 8
// CHECK-NEXT:    [[VFN62:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE61]], i64 2
// CHECK-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[VFN62]], align 8
// CHECK-NEXT:    [[CALL63:%.*]] = call noundef i32 (ptr, ...) [[TMP26]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP25]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[CALL64:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR8]]
// CHECK-NEXT:    call void @_ZN1BC1Ev(ptr noundef nonnull align 8 dereferenceable(9) [[CALL64]])
// CHECK-NEXT:    store ptr [[CALL64]], ptr [[ANS]], align 8
// CHECK-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[ANS]], align 8
// CHECK-NEXT:    [[ISNULL65:%.*]] = icmp eq ptr [[TMP27]], null
// CHECK-NEXT:    br i1 [[ISNULL65]], label %[[DELETE_END69:.*]], label %[[DELETE_NOTNULL66:.*]]
// CHECK:       [[DELETE_NOTNULL66]]:
// CHECK-NEXT:    [[VTABLE67:%.*]] = load ptr, ptr [[TMP27]], align 8
// CHECK-NEXT:    [[VFN68:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE67]], i64 4
// CHECK-NEXT:    [[TMP28:%.*]] = load ptr, ptr [[VFN68]], align 8
// CHECK-NEXT:    call void [[TMP28]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP27]])
// CHECK-NEXT:    br label %[[DELETE_END69]]
// CHECK:       [[DELETE_END69]]:
// CHECK-NEXT:    [[CALL70:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 40) #[[ATTR8]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL70]], i8 0, i64 40, i1 false)
// CHECK-NEXT:    call void @_ZN1FC1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[CALL70]])
// CHECK-NEXT:    [[TMP29:%.*]] = icmp eq ptr [[CALL70]], null
// CHECK-NEXT:    br i1 [[TMP29]], label %[[CAST_END76:.*]], label %[[CAST_NOTNULL71:.*]]
// CHECK:       [[CAST_NOTNULL71]]:
// CHECK-NEXT:    [[VTABLE72:%.*]] = load ptr, ptr [[CALL70]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR73:%.*]] = getelementptr i8, ptr [[VTABLE72]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET74:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR73]], align 8
// CHECK-NEXT:    [[ADD_PTR75:%.*]] = getelementptr inbounds i8, ptr [[CALL70]], i64 [[VBASE_OFFSET74]]
// CHECK-NEXT:    br label %[[CAST_END76]]
// CHECK:       [[CAST_END76]]:
// CHECK-NEXT:    [[CAST_RESULT77:%.*]] = phi ptr [ [[ADD_PTR75]], %[[CAST_NOTNULL71]] ], [ null, %[[DELETE_END69]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT77]], ptr [[ANS]], align 8
// CHECK-NEXT:    [[TMP30:%.*]] = load ptr, ptr [[ANS]], align 8
// CHECK-NEXT:    [[VTABLE78:%.*]] = load ptr, ptr [[TMP30]], align 8
// CHECK-NEXT:    [[VFN79:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE78]], i64 0
// CHECK-NEXT:    [[TMP31:%.*]] = load ptr, ptr [[VFN79]], align 8
// CHECK-NEXT:    [[CALL80:%.*]] = call noundef i32 [[TMP31]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP30]])
// CHECK-NEXT:    [[TMP32:%.*]] = load ptr, ptr [[ANS]], align 8
// CHECK-NEXT:    [[VTABLE81:%.*]] = load ptr, ptr [[TMP32]], align 8
// CHECK-NEXT:    [[VFN82:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE81]], i64 1
// CHECK-NEXT:    [[TMP33:%.*]] = load ptr, ptr [[VFN82]], align 8
// CHECK-NEXT:    [[CALL83:%.*]] = call noundef i32 [[TMP33]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP32]])
// CHECK-NEXT:    [[TMP34:%.*]] = load ptr, ptr [[ANS]], align 8
// CHECK-NEXT:    [[VTABLE84:%.*]] = load ptr, ptr [[TMP34]], align 8
// CHECK-NEXT:    [[VFN85:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE84]], i64 2
// CHECK-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[VFN85]], align 8
// CHECK-NEXT:    [[CALL86:%.*]] = call noundef i32 (ptr, ...) [[TMP35]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP34]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[TMP36:%.*]] = load ptr, ptr [[ANS]], align 8
// CHECK-NEXT:    [[ISNULL87:%.*]] = icmp eq ptr [[TMP36]], null
// CHECK-NEXT:    br i1 [[ISNULL87]], label %[[DELETE_END91:.*]], label %[[DELETE_NOTNULL88:.*]]
// CHECK:       [[DELETE_NOTNULL88]]:
// CHECK-NEXT:    [[VTABLE89:%.*]] = load ptr, ptr [[TMP36]], align 8
// CHECK-NEXT:    [[VFN90:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE89]], i64 4
// CHECK-NEXT:    [[TMP37:%.*]] = load ptr, ptr [[VFN90]], align 8
// CHECK-NEXT:    call void [[TMP37]](ptr noundef nonnull align 8 dereferenceable(9) [[TMP36]])
// CHECK-NEXT:    br label %[[DELETE_END91]]
// CHECK:       [[DELETE_END91]]:
// CHECK-NEXT:    [[CALL92:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 40) #[[ATTR8]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL92]], i8 0, i64 40, i1 false)
// CHECK-NEXT:    call void @_ZN1FC1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[CALL92]])
// CHECK-NEXT:    [[TMP38:%.*]] = icmp eq ptr [[CALL92]], null
// CHECK-NEXT:    br i1 [[TMP38]], label %[[CAST_END98:.*]], label %[[CAST_NOTNULL93:.*]]
// CHECK:       [[CAST_NOTNULL93]]:
// CHECK-NEXT:    [[VTABLE94:%.*]] = load ptr, ptr [[CALL92]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR95:%.*]] = getelementptr i8, ptr [[VTABLE94]], i64 -32
// CHECK-NEXT:    [[VBASE_OFFSET96:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR95]], align 8
// CHECK-NEXT:    [[ADD_PTR97:%.*]] = getelementptr inbounds i8, ptr [[CALL92]], i64 [[VBASE_OFFSET96]]
// CHECK-NEXT:    br label %[[CAST_END98]]
// CHECK:       [[CAST_END98]]:
// CHECK-NEXT:    [[CAST_RESULT99:%.*]] = phi ptr [ [[ADD_PTR97]], %[[CAST_NOTNULL93]] ], [ null, %[[DELETE_END91]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT99]], ptr [[E]], align 8
// CHECK-NEXT:    [[TMP39:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[VTABLE100:%.*]] = load ptr, ptr [[TMP39]], align 8
// CHECK-NEXT:    [[VFN101:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE100]], i64 0
// CHECK-NEXT:    [[TMP40:%.*]] = load ptr, ptr [[VFN101]], align 8
// CHECK-NEXT:    [[CALL102:%.*]] = call noundef i32 [[TMP40]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP39]])
// CHECK-NEXT:    [[TMP41:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[VTABLE103:%.*]] = load ptr, ptr [[TMP41]], align 8
// CHECK-NEXT:    [[VFN104:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE103]], i64 1
// CHECK-NEXT:    [[TMP42:%.*]] = load ptr, ptr [[VFN104]], align 8
// CHECK-NEXT:    [[CALL105:%.*]] = call noundef i32 [[TMP42]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP41]])
// CHECK-NEXT:    [[TMP43:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[VTABLE106:%.*]] = load ptr, ptr [[TMP43]], align 8
// CHECK-NEXT:    [[VFN107:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE106]], i64 2
// CHECK-NEXT:    [[TMP44:%.*]] = load ptr, ptr [[VFN107]], align 8
// CHECK-NEXT:    [[CALL108:%.*]] = call noundef i32 (ptr, ...) [[TMP44]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP43]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[TMP45:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[ISNULL109:%.*]] = icmp eq ptr [[TMP45]], null
// CHECK-NEXT:    br i1 [[ISNULL109]], label %[[DELETE_END113:.*]], label %[[DELETE_NOTNULL110:.*]]
// CHECK:       [[DELETE_NOTNULL110]]:
// CHECK-NEXT:    [[VTABLE111:%.*]] = load ptr, ptr [[TMP45]], align 8
// CHECK-NEXT:    [[VFN112:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE111]], i64 4
// CHECK-NEXT:    [[TMP46:%.*]] = load ptr, ptr [[VFN112]], align 8
// CHECK-NEXT:    call void [[TMP46]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP45]])
// CHECK-NEXT:    br label %[[DELETE_END113]]
// CHECK:       [[DELETE_END113]]:
// CHECK-NEXT:    [[CALL114:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 40) #[[ATTR8]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL114]], i8 0, i64 40, i1 false)
// CHECK-NEXT:    call void @_ZN1GC1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[CALL114]])
// CHECK-NEXT:    [[TMP47:%.*]] = icmp eq ptr [[CALL114]], null
// CHECK-NEXT:    br i1 [[TMP47]], label %[[CAST_END120:.*]], label %[[CAST_NOTNULL115:.*]]
// CHECK:       [[CAST_NOTNULL115]]:
// CHECK-NEXT:    [[VTABLE116:%.*]] = load ptr, ptr [[CALL114]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR117:%.*]] = getelementptr i8, ptr [[VTABLE116]], i64 -32
// CHECK-NEXT:    [[VBASE_OFFSET118:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR117]], align 8
// CHECK-NEXT:    [[ADD_PTR119:%.*]] = getelementptr inbounds i8, ptr [[CALL114]], i64 [[VBASE_OFFSET118]]
// CHECK-NEXT:    br label %[[CAST_END120]]
// CHECK:       [[CAST_END120]]:
// CHECK-NEXT:    [[CAST_RESULT121:%.*]] = phi ptr [ [[ADD_PTR119]], %[[CAST_NOTNULL115]] ], [ null, %[[DELETE_END113]] ]
// CHECK-NEXT:    store ptr [[CAST_RESULT121]], ptr [[E]], align 8
// CHECK-NEXT:    [[TMP48:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[VTABLE122:%.*]] = load ptr, ptr [[TMP48]], align 8
// CHECK-NEXT:    [[VFN123:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE122]], i64 0
// CHECK-NEXT:    [[TMP49:%.*]] = load ptr, ptr [[VFN123]], align 8
// CHECK-NEXT:    [[CALL124:%.*]] = call noundef i32 [[TMP49]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP48]])
// CHECK-NEXT:    [[TMP50:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[VTABLE125:%.*]] = load ptr, ptr [[TMP50]], align 8
// CHECK-NEXT:    [[VFN126:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE125]], i64 1
// CHECK-NEXT:    [[TMP51:%.*]] = load ptr, ptr [[VFN126]], align 8
// CHECK-NEXT:    [[CALL127:%.*]] = call noundef i32 [[TMP51]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP50]])
// CHECK-NEXT:    [[TMP52:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[VTABLE128:%.*]] = load ptr, ptr [[TMP52]], align 8
// CHECK-NEXT:    [[VFN129:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE128]], i64 2
// CHECK-NEXT:    [[TMP53:%.*]] = load ptr, ptr [[VFN129]], align 8
// CHECK-NEXT:    [[CALL130:%.*]] = call noundef i32 (ptr, ...) [[TMP53]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP52]], i32 noundef 1, i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    [[TMP54:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[ISNULL131:%.*]] = icmp eq ptr [[TMP54]], null
// CHECK-NEXT:    br i1 [[ISNULL131]], label %[[DELETE_END135:.*]], label %[[DELETE_NOTNULL132:.*]]
// CHECK:       [[DELETE_NOTNULL132]]:
// CHECK-NEXT:    [[VTABLE133:%.*]] = load ptr, ptr [[TMP54]], align 8
// CHECK-NEXT:    [[VFN134:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE133]], i64 4
// CHECK-NEXT:    [[TMP55:%.*]] = load ptr, ptr [[VFN134]], align 8
// CHECK-NEXT:    call void [[TMP55]](ptr noundef nonnull align 8 dereferenceable(8) [[TMP54]])
// CHECK-NEXT:    br label %[[DELETE_END135]]
// CHECK:       [[DELETE_END135]]:
// CHECK-NEXT:    [[TMP56:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP56]]
//
int main() {
  A *ans = new C();
  delete ans;

  B *b = new D();
  b->f();
  b->g();
  b->h(1,2,3);
  b = new C();
  b->f();
  b->h(1,2,3);
  b = new C();
  b->f();
  b->h(1,2,3);
  b = new F();
  b->f();
  b->g();
  b->h(1,2,3);

  ans = new B();
  delete ans;

  ans = new F();
  ans->f();
  ans->g();
  ans->h(1,2,3);
  delete ans;

  E *e = new F();
  e->f();
  e->g();
  e->h(1,2,3);
  delete e;
  e = new G();
  e->f();
  e->g();
  e->h(1,2,3);
  delete e;
}

//// NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
// ELF: {{.*}}

// CHECK-LABEL: define linkonce_odr void @_ZN1CC1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 8
// CHECK-NEXT:    call void @_ZN1BC2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[TMP0]])
// CHECK-NEXT:    store ptr getelementptr inbounds inrange(-24, 16) ({ [5 x ptr], [11 x ptr] }, ptr @_ZTV1C, i32 0, i32 0, i32 3), ptr [[THIS1]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 8
// CHECK-NEXT:    store ptr getelementptr inbounds inrange(-48, 40) ({ [5 x ptr], [11 x ptr] }, ptr @_ZTV1C, i32 0, i32 1, i32 6), ptr [[ADD_PTR]], align 8
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define linkonce_odr void @_ZN1DC1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 8
// CHECK-NEXT:    call void @_ZN1BC2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[TMP0]])
// CHECK-NEXT:    store ptr getelementptr inbounds inrange(-24, 32) ({ [7 x ptr], [11 x ptr] }, ptr @_ZTV1D, i32 0, i32 0, i32 3), ptr [[THIS1]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 8
// CHECK-NEXT:    store ptr getelementptr inbounds inrange(-48, 40) ({ [7 x ptr], [11 x ptr] }, ptr @_ZTV1D, i32 0, i32 1, i32 6), ptr [[ADD_PTR]], align 8
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define linkonce_odr void @_ZN1BC1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(9) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1BC2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[THIS1]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define linkonce_odr void @_ZN1AD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(9) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1AD2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[THIS1]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define linkonce_odr void @_ZN1ED1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1ED2Ev(ptr noundef nonnull align 8 dereferenceable(8) [[THIS1]])
// CHECK-NEXT:    ret void
//

// CHECK-LABEL: define linkonce_odr void @_ZN1BD1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(9) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1BD2Ev(ptr noundef nonnull align 8 dereferenceable(9) [[THIS1]])
// CHECK-NEXT:    ret void
//

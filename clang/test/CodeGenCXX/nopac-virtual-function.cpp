// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -triple aarch64-linux-gnu -fptrauth-calls -emit-llvm -std=c++11 %s -o - | FileCheck --check-prefixes=CHECK,ELF    %s

struct __attribute__((nopac)) S0 {
  int f;
};

struct __attribute__((nopac)) S1 {
  int f;
};

struct __attribute__((nopac)) S2 : S0, S1 {
  int f;
};

class __attribute__((nopac)) B0 {
public:
  virtual void m0();
  virtual S1 *m1();
  virtual void m2();
  virtual ~B0();
  int f;
};

class __attribute__((nopac)) B1 {
public:
  virtual void m0();
};

class __attribute__((nopac)) D0 : public B0 {
public:
  void m0() override;
  S2 *m1() override;
  virtual void m3();
  int f;
};

class __attribute__((nopac)) D1 : public B0 {
public:
  void m0() override;
  S2 *m1() override;
  int f;
};

class __attribute__((nopac)) D2 : public D0, public D1 {
public:
  void m0() override;
  S2 *m1() override;
  void m3() override;
  int f;
};

class __attribute__((nopac)) V0 : public virtual B0 {
public:
  void m0() override;
  S2 *m1() override;
  int f;
};

class __attribute__((nopac)) V1 : public virtual B0 {
public:
  void m0() override;
  S2 *m1() override;
  ~V1();
  int f;
};

class __attribute__((nopac)) D3 : public V0, public V1 {
public:
  void m0() override;
  S2 *m1() override;
  int f;
};

B1 g_B1;

// CHECK-LABEL: define dso_local void @_ZN2B02m0Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(12) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void B0::m0() {}

// CHECK-LABEL: define dso_local void @_ZN2B12m0Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void B1::m0() {}

// CHECK-LABEL: define dso_local void @_ZN2D02m0Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(16) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void D0::m0() {}

// CHECK-LABEL: define dso_local void @_ZN2D12m0Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(16) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void D1::m0() {}

// CHECK-LABEL: define dso_local void @_ZN2D22m0Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(36) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void D2::m0() {}

// CHECK-LABEL: define dso_local void @_ZN2D32m0Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(32) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void D3::m0() {}

// CHECK-LABEL: define dso_local void @_ZN2V1D1Ev(
// CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(12) [[THIS:%.*]]) unnamed_addr
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN2V1D2Ev(ptr noundef nonnull align 8 dereferenceable(12) [[THIS1]], ptr noundef @_ZTT2V1) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[THIS1]], i64 16
// CHECK-NEXT:    call void @_ZN2B0D2Ev(ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
V1::~V1() {
  m1();
}


// CHECK-LABEL: define dso_local void @_Z8testB0m0P2B0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testB0m0(B0 *a) {
  a->m0();
}


// CHECK-LABEL: define dso_local void @_Z8testB0m1P2B0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef ptr [[TMP1]](ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testB0m1(B0 *a) {
  a->m1();
}


// CHECK-LABEL: define dso_local void @_Z8testB0m2P2B0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testB0m2(B0 *a) {
  a->m2();
}


// CHECK-LABEL: define dso_local void @_Z8testD0m0P2D0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(16) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD0m0(D0 *a) {
  a->m0();
}


// CHECK-LABEL: define dso_local void @_Z8testD0m1P2D0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 5
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef ptr [[TMP1]](ptr noundef nonnull align 8 dereferenceable(16) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD0m1(D0 *a) {
  a->m1();
}


// CHECK-LABEL: define dso_local void @_Z8testD0m2P2D0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD0m2(D0 *a) {
  a->m2();
}


// CHECK-LABEL: define dso_local void @_Z8testD0m3P2D0(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 6
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(16) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD0m3(D0 *a) {
  a->m3();
}



// CHECK-LABEL: define dso_local void @_Z8testD1m0P2D1(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(16) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD1m0(D1 *a) {
  a->m0();
}


// CHECK-LABEL: define dso_local void @_Z8testD1m1P2D1(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 5
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef ptr [[TMP1]](ptr noundef nonnull align 8 dereferenceable(16) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD1m1(D1 *a) {
  a->m1();
}


// CHECK-LABEL: define dso_local void @_Z8testD1m2P2D1(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD1m2(D1 *a) {
  a->m2();
}



// CHECK-LABEL: define dso_local void @_Z8testD2m0P2D2(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(36) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD2m0(D2 *a) {
  a->m0();
}


// CHECK-LABEL: define dso_local void @_Z8testD2m1P2D2(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 5
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef ptr [[TMP1]](ptr noundef nonnull align 8 dereferenceable(36) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD2m1(D2 *a) {
  a->m1();
}


// CHECK-LABEL: define dso_local void @_Z10testD2m2D0P2D2(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN2B02m2Ev(ptr noundef nonnull align 8 dereferenceable(12) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD2m2D0(D2 *a) {
  a->D0::m2();
}


// CHECK-LABEL: define dso_local void @_Z10testD2m2D1P2D2(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 16
// CHECK-NEXT:    call void @_ZN2B02m2Ev(ptr noundef nonnull align 8 dereferenceable(12) [[ADD_PTR]])
// CHECK-NEXT:    ret void
//
void testD2m2D1(D2 *a) {
  a->D1::m2();
}


// CHECK-LABEL: define dso_local void @_Z8testD2m3P2D2(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 6
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(36) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD2m3(D2 *a) {
  a->m3();
}


// CHECK-LABEL: define dso_local void @_Z8testD3m0P2D3(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(32) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD3m0(D3 *a) {
  a->m0();
}


// CHECK-LABEL: define dso_local void @_Z8testD3m1P2D3(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 1
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef ptr [[TMP1]](ptr noundef nonnull align 8 dereferenceable(32) [[TMP0]])
// CHECK-NEXT:    ret void
//
void testD3m1(D3 *a) {
  a->m1();
}


// CHECK-LABEL: define dso_local void @_Z8testD3m2P2D3(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VBASE_OFFSET_PTR:%.*]] = getelementptr i8, ptr [[VTABLE]], i64 -24
// CHECK-NEXT:    [[VBASE_OFFSET:%.*]] = load i64, ptr [[VBASE_OFFSET_PTR]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 [[VBASE_OFFSET]]
// CHECK-NEXT:    [[VTABLE1:%.*]] = load ptr, ptr [[ADD_PTR]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE1]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(12) [[ADD_PTR]])
// CHECK-NEXT:    ret void
//
void testD3m2(D3 *a) {
  a->m2();
}


// CHECK-LABEL: define dso_local void @_Z17testD3Destructor0P2D3(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[ISNULL:%.*]] = icmp eq ptr [[TMP0]], null
// CHECK-NEXT:    br i1 [[ISNULL]], label %[[DELETE_END:.*]], label %[[DELETE_NOTNULL:.*]]
// CHECK:       [[DELETE_NOTNULL]]:
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 3
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(32) [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    br label %[[DELETE_END]]
// CHECK:       [[DELETE_END]]:
// CHECK-NEXT:    ret void
//
void testD3Destructor0(D3 *a) {
  delete a;
}

// CHECK-LABEL: define dso_local void @_Z17testD3Destructor1P2D3(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[ISNULL:%.*]] = icmp eq ptr [[TMP0]], null
// CHECK-NEXT:    br i1 [[ISNULL]], label %[[DELETE_END:.*]], label %[[DELETE_NOTNULL:.*]]
// CHECK:       [[DELETE_NOTNULL]]:
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[COMPLETE_OFFSET_PTR:%.*]] = getelementptr inbounds i64, ptr [[VTABLE]], i64 -2
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[COMPLETE_OFFSET_PTR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 [[TMP1]]
// CHECK-NEXT:    [[VTABLE1:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE1]], i64 2
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP3]](ptr noundef nonnull align 8 dereferenceable(32) [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZdlPv(ptr noundef [[TMP2]]) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    br label %[[DELETE_END]]
// CHECK:       [[DELETE_END]]:
// CHECK-NEXT:    ret void
//
void testD3Destructor1(D3 *a) {
  ::delete a;
}

// CHECK-LABEL: define dso_local void @_Z17testD3Destructor2P2D3(
// CHECK-SAME: ptr noundef [[A:%.*]])
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[VFN:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[VFN]], align 8
// CHECK-NEXT:    call void [[TMP1]](ptr noundef nonnull align 8 dereferenceable(32) [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void testD3Destructor2(D3 *a) {
  a->~D3();
}

// CHECK-LABEL: define dso_local void @_Z23materializeConstructorsv(
// CHECK-SAME: {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B0:%.*]] = alloca [[CLASS_B0:%.*]], align 8
// CHECK-NEXT:    [[B1:%.*]] = alloca [[CLASS_B1:%.*]], align 8
// CHECK-NEXT:    [[D0:%.*]] = alloca [[CLASS_D0:%.*]], align 8
// CHECK-NEXT:    [[D1:%.*]] = alloca [[CLASS_D1:%.*]], align 8
// CHECK-NEXT:    [[D2:%.*]] = alloca [[CLASS_D2:%.*]], align 8
// CHECK-NEXT:    [[D3:%.*]] = alloca [[CLASS_D3:%.*]], align 8
// CHECK-NEXT:    [[V0:%.*]] = alloca [[CLASS_V0:%.*]], align 8
// CHECK-NEXT:    [[V1:%.*]] = alloca [[CLASS_V1:%.*]], align 8
// CHECK-NEXT:    call void @_ZN2B0C1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[B0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2B1C1Ev(ptr noundef nonnull align 8 dereferenceable(8) [[B1]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D0C1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[D0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D1C1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[D1]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D2C1Ev(ptr noundef nonnull align 8 dereferenceable(36) [[D2]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D3C1Ev(ptr noundef nonnull align 8 dereferenceable(32) [[D3]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2V0C1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[V0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2V1C1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[V1]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2V1D1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[V1]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2V0D1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[V0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D3D1Ev(ptr noundef nonnull align 8 dereferenceable(32) [[D3]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D2D1Ev(ptr noundef nonnull align 8 dereferenceable(36) [[D2]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D1D1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[D1]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2D0D1Ev(ptr noundef nonnull align 8 dereferenceable(16) [[D0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZN2B0D1Ev(ptr noundef nonnull align 8 dereferenceable(12) [[B0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void materializeConstructors() {
  B0 B0;
  B1 B1;
  D0 D0;
  D1 D1;
  D2 D2;
  D3 D3;
  V0 V0;
  V1 V1;
}

//// NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
// ELF: {{.*}}
